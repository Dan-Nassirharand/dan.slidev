---
layout: applcommon-two-cols-header
---

# Rules and Recipes

```makefile
target: prerequisites # Rule
	commands # Recipe
```

- Each recipe is run in its own subshell
- When any of the prerequisites change, the target is rebuilt
- Make is whitespace sensitive and `Recipes` are preceded by a `tab` character
- `targets` are generally files that are generated by the `recipes` of that rule

::left::
```makefile
.PHONY: all
all:
	mkdir -p bar
	cd bar
	echo “put into file in bar” >> file.txt
```

::right::

Where will file.txt be placed and why?

<!--
Turning on render whitespace in VS Code by using `ctrl + shift + p` and `View: Toggle Render Whitespace`

Tabs look like a little arrow and it is almost impossible to work on Makefiles without rendering the whitespace.
-->

---
layout: applcommon-two-cols-header
---

# Echoing
- Each recipe is printed on the command line when executed
- Great for debugging, bad for normal use
- Using `@` at the start of a line will suppress the echoing and only print the standard output or standard error of the commands


::left::
```makefile
.PHONY: all
all:
	echo hello
```

```makefile
.PHONY: all
all:
	@echo hello
```

::right::
```bash
$ make
echo hello
hello
```

```bash
$ make
hello
```

<!--
Need to mention global silence after variables
-->

---

# Default Rule

- The first rule in a makefile is the default rule
  - Once a makefile includes other makefiles, this can become complicated
- Specify a target by calling it out directly on the command line
  - `make -f target.mk upload`
- Any target in a makefile is valid, however the most commonly called out targets are...

---

# Phony Targets

- A modifier to a target that tells make that the target is not a real file and should always be executed

```makefile
.PHONY: clean
clean:
	@rm -rf build
```

- If added as a prerequisite to another rule, it will cause that rule to always be rerun, since this dependency is always executed

---
layout: applcommon-two-cols-header
---

# Prerequisites

- All prerequisites are run before the recipes of the target can be called

```makefile
target: prereq1 prereq2 prereq3
	<recipe>
```

- Make determines if a prerequisite has changed by the file's timestamp. If the prerequisite timestamp is newer than the target's timestamp, the target must be rebuilt
- When running with jobs, the prerequisites can be run in parallel speeding up the entire process

<!--
Don't forget that phony targets are always marked as needing to be rebuilt

When making the prerequisites its important to think about what a target is truly dependent on. Putting extra or unneeded prerequisites can make the job take extra time that wastes everyone's time.
 -->
---

# Folder Timestamps

Consider this makefile:

```makefile
build/test.o: build
	touch build/test.o

build:
	mkdir -p build
```

On the first run, everything is created as normal
```bash
$ make
mkdir -p build
touch build/test.o
```

Running it again gives:

```bash
$ make
make: 'build/test.o' is up to date.
```

All is good!

---

# Folder Timestamps

Adding another file to this folder and re-running make makes `test.o` rebuild?
```bash
$ touch build/file.txt
$ make
touch build/test.o
```

This is because a folder's timestamp is updated whenever a file inside of it is edited.

```bash
$ make
mkdir -p build
touch build/test.o
$ ls -l
drwxrwxr-x   2 beeler beeler  4096 Oct 11 16:21 build
$ touch build/file.txt
$ ls -l
drwxrwxr-x   2 beeler beeler  4096 Oct 11 16:23 build
```

This could cause a long process to rebuild for no reason!

---
layout: applcommon-two-cols-header
---

# Order-Only Prerequisites

Prerequisites that are built before the target but do not force the target to rebuild if updated.

```makefile
target: prerequisites | order-only prerequisites
```

Using this knowledge we can fix our makefile by making the folder an order-only prerequisite:

::left::
```makefile
build/test.o: | build
	touch build/test.o

build:
	mkdir -p build
```

::right::
```bash
$ make
mkdir -p build
touch build/test.o
$ touch build/file.txt
$ make
make: 'build/test.o' is up to date.
```

<!--
We use this for tool setup too.
-->

---
src: ./variables.md
---

---
src: ./conditionals.md
---

---
src: ./functions.md
---

---
layout: applcommon-two-cols-header
---

# Multiple Targets

- Rules can have multiple targets!
- The target is run multiple times, it does not indicate that a rule makes two files at the same time

::left::
```makefile
.PHONY: all
all: foo bar
	@echo done

.PHONY: foo bar
foo bar:
	@echo $@
```

::right::
```bash
$ make
foo
bar
done
```

---
layout: applcommon-two-cols-header
---

# Pattern Rules

- Used to build a class of files with with a matching file path, using the wildcard `%`
- Pattern rules do not search the file system for files, targets need to be requested as a dependency in another rule
- Using automatic variables is required in most cases

::left::
```makefile
.PHONY: all
all: main.c foo.c bar.c

%.o: %.c
	gcc -c $< -o $@
```

::right::

```bash
$ make
gcc -c main.c -o main.o
gcc -c foo.c -o foo.o
gcc -c bar.c -o bar.o
```

<!--
These are called implicit rules, since they are how to make a class of rules
-->

---

# Pattern Rules

- The `%` has to match exactly for the entire rule
- No error message when `%` does not match, outside of `No rule to make file X`.

```makefile
# Example from image.mk, this makes the .c file for compiling parametric data into the .elf for debug purposes
$(OUTPUT_DIR)/%.c: $(OUTPUT_DIR)/%.pxml %.prexml %.postxml $(OUTPUT_DIR)
	@echo Creating $@...
	@$(LUA53) $(LUA_XML_TO_C) --xml $< --pre $*.prexml --post $*.postxml --output $@ --header --endianness $(ENDIANNESS)
```

---

# Automatic Rules

- Make comes built in with predefined implicit rules.
  - Here at AP we refer to these as Automatic Rules because that sounds more reasonable.
- The list of rules can be found [here](https://www.gnu.org/software/make/manual/html_node/Catalogue-of-Rules.html) and the variables that go into them
  - The list of variables can be found [here](https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html)
- Enables the compiling of very simple programs without a makefile!

``` bash
$ make main
cc     main.c   -o main
$ ./main
Hello, World!
```

- Outside of being super useful on tiny programs, it gives us a standard format to follow when making our makefiles.

---
layout: applcommon-two-cols-header
---

# Adding Dependencies

- Dependencies do not have to be added when a rule is defined and can be added before or after a rule is defined

::left::
```makefile
.PHONY: all
all:
	@echo $^

all: test

.PHONY: test
test:
	@echo inside test rule
```

::right::
```bash
$ make
inside test rule
test
```

<!--
This is a fundamental concept that makes make amazing.
-->
